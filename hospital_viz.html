  <!DOCTYPE html>
  <html lang="en">
  <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Hospital Graph - Unsafe Paths</title>
  <script src="https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js"></script>
  <style>
    body { font-family: 'Segoe UI', sans-serif; margin:0; display:flex; height:100vh; background:#f0f2f5; }
    #sidebar { width:320px; background:#fff; padding:20px; overflow-y:auto; box-shadow:2px 0 10px rgba(0,0,0,0.1); display:flex; flex-direction:column; }
    #main { flex:1; padding:20px; overflow:auto; display:flex; flex-direction:column; }
    h2 { margin-top:0; color:#333; }
    .suspicious-item { padding:12px; margin-bottom:10px; background:#ffeaea; border-left:5px solid #ff6b6b; border-radius:6px; display:flex; justify-content:space-between; align-items:center; transition: all 0.2s; }
    .suspicious-item:hover { background:#ffdada; transform: scale(1.02); }
    .btn { padding:6px 12px; border:none; border-radius:5px; cursor:pointer; font-weight:bold; transition: all 0.2s; }
    .btn-view { background:#4CAF50; color:white; }
    .btn-view:hover { background:#45a049; }
    .btn-back { background:#2196F3; color:white; margin-bottom:20px; }
    .btn-back:hover { background:#1e88e5; }
    .btn-full { background:#ff9800; color:white; margin-top:10px; }
    .btn-full:hover { background:#fb8c00; }
    #mermaid-graph { background:white; padding:20px; border-radius:10px; box-shadow:0 0 15px rgba(0,0,0,0.1); min-height:400px; margin-bottom:10px; overflow:auto; position: relative; }
    .path-info { margin-top: 10px; font-size: 0.9em; color: #666; background: #f5f5f5; padding: 10px; border-radius: 5px; }
    .loading { text-align: center; padding: 20px; color: #666; }
    .error { text-align: center; padding: 20px; color: #d32f2f; background: #ffebee; border-radius: 5px; }
    #graph-container { width: 100%; height: 100%; min-height: 500px; }
    
    /* Node info tooltip */
    .node-tooltip {
      position: absolute;
      background: rgba(0, 0, 0, 0.9);
      color: white;
      padding: 10px;
      border-radius: 5px;
      font-size: 12px;
      max-width: 300px;
      z-index: 1000;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
      box-shadow: 0 4px 8px rgba(0,0,0,0.3);
    }
    
    .node-tooltip.visible {
      opacity: 1;
    }
    
    .node-tooltip strong {
      display: block;
      margin-bottom: 5px;
      color: #4CAF50;
    }
    
    .node-tooltip .node-type {
      color: #ff9800;
      font-weight: bold;
    }
    
    .node-tooltip .node-id {
      color: #2196F3;
      font-family: monospace;
    }
  </style>
  </head>
  <body>

  <div id="sidebar">
    <h2>Suspicious Paths</h2>
    <div id="issues-list" class="loading">Loading paths...</div>
  </div>

  <div id="main">
    <div id="graph-container">
      <div id="mermaid-graph" class="loading">Graph will render here...</div>
      <div id="node-tooltip" class="node-tooltip"></div>
    </div>
    <button class="btn btn-full" id="btnFullGraph" onclick="renderFullGraph()" style="display:none;">Show Full Graph</button>
    <button class="btn btn-back" id="btnBackFull" style="display:none;" onclick="renderFullGraph()">← Back to Full Graph</button>
  </div>

  <script>
  // Global variables
  let fullGraphCode = '';
  let unsafePaths = [];
  let graphData = { nodes: {}, edges: [] };
  let currentView = 'full';

  // Predefined unsafe paths based on your analysis
  const predefinedUnsafePaths = [
    {
      id: 1,
      name: "Path 1: Source to Sink via Email & Auth",
      nodes: ['N0', 'N1', 'N3', 'N21', 'N23', 'N12', 'N10'],
      description: "Source → Auth Service → Email Dispatcher → Event Broker → Shipping Engine → Auth Service → Sink"
    },
    {
      id: 2,
      name: "Path 2: Source to Sink via Business Logic",
      nodes: ['N0', 'N2', 'N3', 'N5', 'N6', 'N10'],
      description: "Source → User Profile → Email Dispatcher → Business Logic → Event Handler → Sink"
    },
    {
      id: 3,
      name: "Path 3: Alternative Business Logic Path",
      nodes: ['N0', 'N2', 'N4', 'N6', 'N10'],
      description: "Source → User Profile → Business Logic → Event Handler → Sink"
    },
    {
      id: 4,
      name: "Path 4: Second Source to Sink via Logging",
      nodes: ['N15', 'N13', 'N12', 'N10'],
      description: "Source → Shared Logging → Auth Service → Sink"
    },
    {
      id: 5,
      name: "Path 5: Second Source via User Controller",
      nodes: ['N15', 'N14', 'N12', 'N10'],
      description: "Source → User Controller → Auth Service → Sink"
    },
    {
      id: 6,
      name: "Path 6: Order Processing Path",
      nodes: ['N15', 'N16', 'N18', 'N24', 'N27', 'N29'],
      description: "Source → User Profile → Order Processor → Order Processor → Business Logic → Sink"
    },
    {
      id: 7,
      name: "Path 7: Complex Event Processing",
      nodes: ['N15', 'N17', 'N18', 'N20', 'N21', 'N23', 'N25', 'N27', 'N29'],
      description: "Source → Inventory → Order Processor → DTO → Event Broker → Shipping Engine → Shipping Engine → Business Logic → Sink"
    },
    {
      id: 8,
      name: "Path 8: Service Registry Path",
      nodes: ['N0', 'N28', 'N26', 'N29'],
      description: "Source → Service Registry → Shared Logging → Sink"
    },
    {
      id: 9,
      name: "Path 9: Direct Source to Sink",
      nodes: ['N0', 'N29'],
      description: "Source → Sink (Direct Connection)"
    },
    {
      id: 10,
      name: "Path 10: User Controller to Business Logic",
      nodes: ['N15', 'N14', 'N27', 'N29'],
      description: "Source → User Controller → Business Logic → Sink"
    }
  ];

  // Initialize Mermaid
  function initializeMermaid() {
    if (typeof mermaid !== 'undefined') {
      try {
        mermaid.initialize({
          startOnLoad: false,
          theme: 'default',
          securityLevel: 'loose',
          flowchart: {
            useMaxWidth: true,
            htmlLabels: true,
            curve: 'basis'
          }
        });
        console.log('Mermaid initialized successfully');
        return true;
      } catch (error) {
        console.error('Mermaid initialization failed:', error);
        return false;
      }
    } else {
      console.error('Mermaid library not loaded');
      return false;
    }
  }

  // Load GraphML file
  async function loadGraphML(url) {
    try {
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(`Failed to load GraphML file: ${response.status}`);
      }
      const text = await response.text();
      const parser = new DOMParser();
      return parser.parseFromString(text, "application/xml");
    } catch (error) {
      console.error('Error loading GraphML:', error);
      showError(`Error loading graph: ${error.message}`);
      return null;
    }
  }

  // Parse GraphML data
  function parseGraphML(xml) {
    const nodes = {};
    const edges = [];
    
    // Parse nodes
    xml.querySelectorAll('node').forEach(node => {
      const id = node.getAttribute('id');
      const nameNode = node.querySelector('data[key="d0"]');
      const typeNode = node.querySelector('data[key="d1"]');
      
      if (nameNode && typeNode) {
        nodes[id] = {
          name: nameNode.textContent,
          type: typeNode.textContent,
          displayName: `${nameNode.textContent}`,
          id: id
        };
      }
    });

    // Parse edges
    xml.querySelectorAll('edge').forEach(edge => {
      const source = edge.getAttribute('source');
      const target = edge.getAttribute('target');
      const idNode = edge.querySelector('data[key="d2"]');
      const interactionNode = edge.querySelector('data[key="d3"]');
      
      if (source && target && nodes[source] && nodes[target]) {
        edges.push({
          source,
          target,
          id: idNode ? idNode.textContent : '',
          interaction: interactionNode ? interactionNode.textContent : 'interacts'
        });
      }
    });

    return { nodes, edges };
  }

  // Convert GraphML to Mermaid code for full graph
  function graphToMermaidFull(graphData) {
    let mermaidStr = 'graph TB\n';
    
    // Define all nodes with their types
    Object.entries(graphData.nodes).forEach(([id, node]) => {
      let style = 'internal';
      if (node.type === 'source') style = 'source';
      else if (node.type === 'sink') style = 'sink';
      else if (node.type === 'sanitizer') style = 'sanitizer';
      
      // Check if it's a sensitive node (from your list)
      const sensitiveNodes = ['N3', 'N6', 'N9', 'N12', 'N18', 'N21', 'N24', 'N27'];
      if (sensitiveNodes.includes(id)) {
        style = 'sensitive';
      }
      
      mermaidStr += `    ${id}["${node.displayName}"]:::${style}\n`;
    });
    
    // Add all edges
    graphData.edges.forEach(edge => {
      mermaidStr += `    ${edge.source} --> ${edge.target}\n`;
    });
    
    // Add styling
    mermaidStr += `\n    classDef source fill:#ff9800,stroke:#e68900,stroke-width:2px,color:#000;\n`;
    mermaidStr += `    classDef sink fill:#f44336,stroke:#d32f2f,stroke-width:2px,color:#000;\n`;
    mermaidStr += `    classDef sensitive fill:#ffeb3b,stroke:#fbc02d,stroke-width:2px,color:#000;\n`;
    mermaidStr += `    classDef sanitizer fill:#4caf50,stroke:#388e3c,stroke-width:2px,color:#000;\n`;
    mermaidStr += `    classDef internal fill:#2196f3,stroke:#1976d2,stroke-width:2px,color:#fff;\n`;
    
    return mermaidStr;
  }

  // Convert path to Mermaid code with highlighting
  function pathToMermaid(graphData, path) {
    let mermaidStr = 'graph TB\n';
    
    // Add nodes in the path with highlighting
    path.nodes.forEach(nodeId => {
      const node = graphData.nodes[nodeId];
      if (node) {
        let style = 'internal';
        if (node.type === 'source') style = 'source';
        else if (node.type === 'sink') style = 'sink';
        else if (node.type === 'sanitizer') style = 'sanitizer';
        
        const sensitiveNodes = ['N3', 'N6', 'N9', 'N12', 'N18', 'N21', 'N24', 'N27'];
        if (sensitiveNodes.includes(nodeId)) {
          style = 'sensitive';
        }
        
        // Add highlight class to all nodes in the path
        mermaidStr += `    ${nodeId}["${node.displayName}"]:::${style}:::highlightPath\n`;
      }
    });
    
    // Add edges in the path with highlighting
    for (let i = 0; i < path.nodes.length - 1; i++) {
      const source = path.nodes[i];
      const target = path.nodes[i + 1];
      
      // Use dotted line for path edges
      mermaidStr += `    ${source} -.-> ${target}\n`;
    }
    
    // Add styling with highlight
    mermaidStr += `\n    classDef source fill:#ff9800,stroke:#e68900,stroke-width:2px,color:#000;\n`;
    mermaidStr += `    classDef sink fill:#f44336,stroke:#d32f2f,stroke-width:2px,color:#000;\n`;
    mermaidStr += `    classDef sensitive fill:#ffeb3b,stroke:#fbc02d,stroke-width:2px,color:#000;\n`;
    mermaidStr += `    classDef sanitizer fill:#4caf50,stroke:#388e3c,stroke-width:2px,color:#000;\n`;
    mermaidStr += `    classDef internal fill:#2196f3,stroke:#1976d2,stroke-width:2px,color:#fff;\n`;
    mermaidStr += `    classDef highlightPath fill:#ffcccc,stroke:#ff4d4d,stroke-width:3px,color:#000;\n`;
    
    return mermaidStr;
  }

  // Setup node hover interactions
  function setupNodeHover() {
    const graphElement = document.getElementById('mermaid-graph');
    const tooltip = document.getElementById('node-tooltip');
    
    if (!graphElement || !tooltip) return;
    
    // Remove existing event listeners
    graphElement.removeEventListener('mouseover', handleNodeMouseOver);
    graphElement.removeEventListener('mouseout', handleNodeMouseOut);
    graphElement.removeEventListener('mousemove', handleNodeMouseMove);
    
    // Add new event listeners
    graphElement.addEventListener('mouseover', handleNodeMouseOver);
    graphElement.addEventListener('mouseout', handleNodeMouseOut);
    graphElement.addEventListener('mousemove', handleNodeMouseMove);
  }

  function handleNodeMouseOver(event) {
    const target = event.target;
    if (target.classList.contains('node') || target.closest('.node')) {
      const nodeElement = target.classList.contains('node') ? target : target.closest('.node');
      const nodeId = getNodeIdFromElement(nodeElement);
      
      if (nodeId && graphData.nodes[nodeId]) {
        showNodeTooltip(nodeId, event.clientX, event.clientY);
      }
    }
  }

  function handleNodeMouseOut(event) {
    const target = event.target;
    if (target.classList.contains('node') || target.closest('.node')) {
      hideNodeTooltip();
    }
  }

  function handleNodeMouseMove(event) {
    const tooltip = document.getElementById('node-tooltip');
    if (tooltip.classList.contains('visible')) {
      tooltip.style.left = (event.clientX + 15) + 'px';
      tooltip.style.top = (event.clientY + 15) + 'px';
    }
  }

  function getNodeIdFromElement(nodeElement) {
    // Try to find the node ID from various possible locations in the Mermaid SVG
    const label = nodeElement.querySelector('.label');
    if (label) {
      const textContent = label.textContent || '';
      // Look for node ID in the text content or try to match with known nodes
      for (const nodeId in graphData.nodes) {
        if (textContent.includes(graphData.nodes[nodeId].displayName)) {
          return nodeId;
        }
      }
    }
    
    // Alternative: try to get from the parent group ID or data attributes
    const parentGroup = nodeElement.closest('g');
    if (parentGroup && parentGroup.id) {
      const match = parentGroup.id.match(/flowchart-(.+?)-/);
      if (match && match[1]) {
        return match[1];
      }
    }
    
    return null;
  }

  function showNodeTooltip(nodeId, x, y) {
    const tooltip = document.getElementById('node-tooltip');
    const node = graphData.nodes[nodeId];
    
    if (!node) return;
    
    // Determine node type with description
    let typeDescription = node.type;
    const sensitiveNodes = ['N3', 'N6', 'N9', 'N12', 'N18', 'N21', 'N24', 'N27'];
    if (sensitiveNodes.includes(nodeId)) {
      typeDescription = 'Sensitive Node';
    } else if (node.type === 'source') {
      typeDescription = 'Source Node';
    } else if (node.type === 'sink') {
      typeDescription = 'Sink Node';
    } else if (node.type === 'sanitizer') {
      typeDescription = 'PII Sanitizer';
    } else if (node.type === 'internal') {
      typeDescription = 'Internal Service';
    }
    
    // Find connected edges
    const incomingEdges = graphData.edges.filter(edge => edge.target === nodeId);
    const outgoingEdges = graphData.edges.filter(edge => edge.source === nodeId);
    
    tooltip.innerHTML = `
      <strong>${node.displayName}</strong>
      <div class="node-id">ID: ${nodeId}</div>
      <div class="node-type">Type: ${typeDescription}</div>
      <div>Incoming: ${incomingEdges.length} connections</div>
      <div>Outgoing: ${outgoingEdges.length} connections</div>
      ${sensitiveNodes.includes(nodeId) ? '<div style="color: #ffeb3b; margin-top: 5px;">⚠️ Contains sensitive data</div>' : ''}
      ${node.type === 'source' ? '<div style="color: #ff9800; margin-top: 5px;">📥 Data entry point</div>' : ''}
      ${node.type === 'sink' ? '<div style="color: #f44336; margin-top: 5px;">📤 Data exit point</div>' : ''}
      ${node.type === 'sanitizer' ? '<div style="color: #4caf50; margin-top: 5px;">🛡️ Data protection</div>' : ''}
    `;
    
    tooltip.style.left = (x + 15) + 'px';
    tooltip.style.top = (y + 15) + 'px';
    tooltip.classList.add('visible');
  }

  function hideNodeTooltip() {
    const tooltip = document.getElementById('node-tooltip');
    tooltip.classList.remove('visible');
  }

  // Render the list of suspicious paths
  function renderSuspiciousPaths() {
    const container = document.getElementById('issues-list');
    
    if (unsafePaths.length === 0) {
      container.innerHTML = '<div class="loading">No unsafe paths found</div>';
      return;
    }
    
    container.innerHTML = '<h3>Found ' + unsafePaths.length + ' unsafe paths</h3>';
    unsafePaths.forEach(path => {
      const div = document.createElement('div');
      div.className = 'suspicious-item';
      div.innerHTML = `
        <div style="flex: 1;">
          <strong>${path.name}</strong><br>
          <small style="font-size: 0.8em; color: #666;">${path.description}</small>
        </div>
        <button class="btn btn-view" onclick="viewPath(${path.id})">View</button>
      `;
      container.appendChild(div);
    });
  }

  // Properly render Mermaid diagram
  function renderMermaid(code) {
    const container = document.getElementById('mermaid-graph');
    
    try {
      console.log('Rendering Mermaid code:', code);
      
      // Clear previous content
      container.innerHTML = '<div class="mermaid">' + code + '</div>';
      
      // Re-initialize mermaid for the new content
      if (typeof mermaid !== 'undefined') {
        mermaid.init(undefined, container.querySelectorAll('.mermaid')).then(() => {
          // Setup hover interactions after Mermaid renders
          setTimeout(setupNodeHover, 100);
        });
      } else {
        console.error('Mermaid not available for rendering');
        container.innerHTML = '<div class="error">Mermaid library not loaded</div>';
      }
    } catch (error) {
      console.error('Error rendering Mermaid:', error);
      container.innerHTML = '<div class="error">Error rendering graph: ' + error.message + '<br><br>Mermaid Code:<br><pre>' + code + '</pre></div>';
    }
  }

  // Show error message
  function showError(message) {
    const container = document.getElementById('mermaid-graph');
    container.innerHTML = '<div class="error">' + message + '</div>';
  }

  // Render full graph
  function renderFullGraph() {
    document.getElementById('btnBackFull').style.display = 'none';
    document.getElementById('btnFullGraph').style.display = 'inline-block';
    currentView = 'full';
    
    if (fullGraphCode) {
      renderMermaid(fullGraphCode);
    } else {
      showError('Full graph not available');
    }
  }

  // View single path
  function viewPath(pathId) {
    const path = unsafePaths.find(p => p.id === pathId);
    if (!path) {
      showError('Path not found');
      return;
    }
    
    const pathCode = pathToMermaid(graphData, path);
    renderMermaid(pathCode);
    
    // Show back button, hide full graph button
    document.getElementById('btnBackFull').style.display = 'inline-block';
    document.getElementById('btnFullGraph').style.display = 'none';
    currentView = 'path';
    
    // Add path info
    const container = document.getElementById('mermaid-graph');
    const infoDiv = document.createElement('div');
    infoDiv.className = 'path-info';
    
    const sensitiveNodesInPath = path.nodes.filter(id => 
      ['N3', 'N6', 'N9', 'N12', 'N18', 'N21', 'N24', 'N27'].includes(id)
    ).map(id => graphData.nodes[id].name);
    
    infoDiv.innerHTML = `
      <strong>${path.name}</strong><br>
      <strong>Path:</strong> ${path.nodes.join(' → ')}<br>
      <strong>Description:</strong> ${path.description}<br>
      <strong>Path Length:</strong> ${path.nodes.length} nodes<br>
      <strong>Sensitive Nodes:</strong> ${sensitiveNodesInPath.join(', ')}
    `;
    
    container.appendChild(infoDiv);
  }

  // Initialize the application
  async function initialize() {
    console.log('Initializing application...');
    
    // Initialize Mermaid first
    if (!initializeMermaid()) {
      showError('Failed to initialize Mermaid diagram library');
      return;
    }
    
    // Show loading state
    document.getElementById('mermaid-graph').innerHTML = '<div class="loading">Loading graph data...</div>';
    
    // Use predefined unsafe paths for now
    unsafePaths = predefinedUnsafePaths;
    
    // Load the GraphML file to get the full graph structure
    const xml = await loadGraphML('hospital_graph.graphml');
    if (!xml) {
      showError('Failed to load GraphML file. Using predefined paths only.');
      // Still render the UI with predefined paths
      renderSuspiciousPaths();
      renderPredefinedFullGraph();
      return;
    }
    
    // Parse the GraphML data
    graphData = parseGraphML(xml);
    console.log('Parsed graph data:', graphData);
    
    // Generate full graph
    fullGraphCode = graphToMermaidFull(graphData);
    console.log('Generated Mermaid code for full graph');
    
    // Render the UI
    renderSuspiciousPaths();
    renderFullGraph();
    
    document.getElementById('btnFullGraph').style.display = 'inline-block';
  }

  // Fallback if GraphML loading fails
  function renderPredefinedFullGraph() {
    const fallbackCode = `graph TB
      N0["source-node-0"]:::source
      N15["source-node-15"]:::source
      N10["sink-node-10"]:::sink
      N29["sink-node-29"]:::sink
      N3["email-notification-dispatcher-3"]:::sensitive
      N6["event-handler-6"]:::sensitive
      N9["shipping-calculator-engine-9"]:::sensitive
      N12["authentication-service-12"]:::sensitive
      N18["order-processor-18"]:::sensitive
      N21["event-broker-21"]:::sensitive
      N24["order-processor-24"]:::sensitive
      N27["business-logic-facade-27"]:::sensitive
      N1["auth-service-1"]:::internal
      N2["user-profile-service-2"]:::internal
      N4["business-logic-facade-4"]:::internal
      N5["business-logic-facade-5"]:::internal
      N7["pii-scrubber-7"]:::sanitizer
      N8["auth-service-8"]:::internal
      N13["shared-logging-service-13"]:::internal
      N14["user-controller-14"]:::internal
      N16["user-profile-service-16"]:::internal
      N17["inventory-management-service-17"]:::internal
      N19["business-logic-facade-19"]:::internal
      N20["data-transfer-object-20"]:::internal
      N22["user-profile-service-22"]:::internal
      N23["shipping-calculator-engine-23"]:::internal
      N25["shipping-calculator-engine-25"]:::internal
      N26["shared-logging-service-26"]:::internal
      N28["service-registry-28"]:::internal
      
      classDef source fill:#ff9800,stroke:#e68900,stroke-width:2px,color:#000
      classDef sink fill:#f44336,stroke:#d32f2f,stroke-width:2px,color:#000
      classDef sensitive fill:#ffeb3b,stroke:#fbc02d,stroke-width:2px,color:#000
      classDef sanitizer fill:#4caf50,stroke:#388e3c,stroke-width:2px,color:#000
      classDef internal fill:#2196f3,stroke:#1976d2,stroke-width:2px,color:#fff`;
    
    fullGraphCode = fallbackCode;
    renderMermaid(fallbackCode);
  }

  // Start the application when page loads
  document.addEventListener('DOMContentLoaded', function() {
    console.log('DOM loaded, starting initialization...');
    initialize();
  });
  </script>

  </body>
  </html>